
/*
 * Copyright (c) 2000, 2023, Oracle and/or its affiliates.
 *
 * Licensed under the Universal Permissive License v 1.0 as shown at
 * https://oss.oracle.com/licenses/upl.
 */

// ---- class: com.tangosol.coherence.component.net.message.MapEventMessage

package com.tangosol.coherence.component.net.message;

import com.tangosol.io.ReadBuffer;
import com.tangosol.util.Binary;
import com.tangosol.util.ExternalizableHelper;
import com.tangosol.util.MapEvent;
import com.tangosol.util.NullImplementation;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;

/**
 * Remote MapEvent notification.
 */
/*
* Integrates
*     com.tangosol.util.MapEvent
*     using Component.Dev.Compiler.Integrator.Wrapper
*/
@SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
public class MapEventMessage
        extends    com.tangosol.coherence.component.net.Message
    {
    // ---- Fields declarations ----
    
    /**
     * Property CacheId
     *
     * The corresponding cache id.
     */
    private long __m_CacheId;
    
    /**
     * Property ENTRY_DELETED
     *
     */
    public static final int ENTRY_DELETED = 3; // com.tangosol.util.MapEvent.ENTRY_DELETED;
    
    /**
     * Property ENTRY_INSERTED
     *
     */
    public static final int ENTRY_INSERTED = 1; // com.tangosol.util.MapEvent.ENTRY_INSERTED;
    
    /**
     * Property ENTRY_UPDATED
     *
     */
    public static final int ENTRY_UPDATED = 2; // com.tangosol.util.MapEvent.ENTRY_UPDATED;
    
    /**
     * Property EventSUID
     *
     * A unique event SUID generated by the event originator.
     */
    private long __m_EventSUID;
    
    /**
     * Property EventType
     *
     * The event type (one of the MapEvent.ENTRY_* constants) further decorated
     * with the EVT_* flags.
     */
    private int __m_EventType;
    
    /**
     * Property EVT_DELTA_COMPRESSED
     *
     * Flag indicating an event whose NewValue should be delta-compressed
     * during serialization.
     * 
     * 0x10
     */
    public static final int EVT_DELTA_COMPRESSED = 16;
    
    /**
     * Property EVT_EXPIRED
     *
     * Flag indicating an event resulting from expiration.
     * 
     * 0x80
     */
    public static final int EVT_EXPIRED = 128;
    
    /**
     * Property EVT_OPT_NEW_SKIP
     *
     * Flag indicating that the NewValue of this event has been optimized out
     * and should be replaced with the corresponding NewValue.
     * 
     * 0x100
     */
    public static final int EVT_OPT_NEW_SKIP = 256;
    
    /**
     * Property EVT_OPT_NEW_SWAP
     *
     * Flag indicating that the NewValue of this event has been optimized out
     * and should be replaced with the corresponding OldValue.
     * 
     * Note: this could only happen if a regular insert or update event is
     * chained with a synthetic delete event.
     * 
     * 0x200
     */
    public static final int EVT_OPT_NEW_SWAP = 512;
    
    /**
     * Property EVT_OPT_OLD_SKIP
     *
     * Flag indicating that the OldValue of this event has been optimized out
     * and should be replaced with the corresponding OldValue.
     * 
     * 0x400
     */
    public static final int EVT_OPT_OLD_SKIP = 1024;
    
    /**
     * Property EVT_OPT_OLD_SWAP
     *
     * Flag indicating that the OldValue of this event has been optimized out
     * and should be replaced with the corresponding NewValue.
     * 
     * Note: this could only happen if a regular delete event is chained with a
     * synthetic insert event.
     * 
     * 0x800
     */
    public static final int EVT_OPT_OLD_SWAP = 2048;
    
    /**
     * Property EVT_PRIMING
     *
     * Flag indicating that values of this event is emitted due to a primining
     * request.
     * 
     * 0x20
     */
    public static final int EVT_PRIMING = 64;
    
    /**
     * Property EVT_SYNTHETIC
     *
     * Flag indicating a synthetic event.
     * 
     * 0x8
     */
    public static final int EVT_SYNTHETIC = 8;
    
    /**
     * Property EVT_TRANSFORMED
     *
     * Flag indicating that values of this event have been transformed.
     * 
     * 0x20
     */
    public static final int EVT_TRANSFORMED = 32;
    
    /**
     * Property EVT_TYPE_MASK
     *
     * Mask for MapEvent types (ENTRY_*).
     */
    public static final int EVT_TYPE_MASK = 7;
    
    /**
     * Property FilterId
     *
     * An array of Filter Ids that were responsible for raising this event.
     */
    private long[] __m_FilterId;
    
    /**
     * Property Key
     *
     * The key.
     */
    private com.tangosol.util.Binary __m_Key;
    
    /**
     * Property NewValue
     *
     * The new value (could be null for lite events).
     */
    private com.tangosol.util.Binary __m_NewValue;
    
    /**
     * Property OldestPendingEventSUID
     *
     * A SUID for the oldest pending event SUID issued by the event producer;
     * -1 if there are none.
     */
    private long __m_OldestPendingEventSUID;
    
    /**
     * Property OldValue
     *
     * The old value (could be null for lite events).
     */
    private com.tangosol.util.Binary __m_OldValue;
    
    /**
     * Property Partition
     *
     */
    private int __m_Partition;
    
    /**
     * Property Version
     *
     */
    private long __m_Version;
    
    // Default constructor
    public MapEventMessage()
        {
        this(null, null, true);
        }
    
    // Initializing constructor
    public MapEventMessage(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
        {
        super(sName, compParent, false);
        
        if (fInit)
            {
            __init();
            }
        }
    
    // Main initializer
    public void __init()
        {
        // private initialization
        __initPrivate();
        
        // state initialization: public and protected properties
        try
            {
            setNotifyDelivery(true);
            }
        catch (java.lang.Exception e)
            {
            // re-throw as a runtime exception
            throw new com.tangosol.util.WrapperException(e);
            }
        
        // signal the end of the initialization
        set_Constructed(true);
        }
    
    // Private initializer
    protected void __initPrivate()
        {
        
        super.__initPrivate();
        }
    
    //++ getter for static property _Instance
    /**
     * Getter for property _Instance.<p>
    * Auto generated
     */
    public static com.tangosol.coherence.Component get_Instance()
        {
        return new com.tangosol.coherence.component.net.message.MapEventMessage();
        }
    
    //++ getter for static property _CLASS
    /**
     * Getter for property _CLASS.<p>
    * Property with auto-generated accessor that returns the Class object for a
    * given component.
     */
    public static Class get_CLASS()
        {
        Class clz;
        try
            {
            clz = Class.forName("com.tangosol.coherence/component/net/message/MapEventMessage".replace('/', '.'));
            }
        catch (ClassNotFoundException e)
            {
            throw new NoClassDefFoundError(e.getMessage());
            }
        return clz;
        }
    
    //++ getter for autogen property _Module
    /**
     * This is an auto-generated method that returns the global [design time]
    * parent component.
    * 
    * Note: the class generator will ignore any custom implementation for this
    * behavior.
     */
    private com.tangosol.coherence.Component get_Module()
        {
        return this;
        }
    
    //++ com.tangosol.util.MapEvent integration
    // Access optimization
    // properties integration
    // methods integration
    //-- com.tangosol.util.MapEvent integration
    
    /**
     * Process the events represented by the event holder and tag the EventType
    * with flags that indicate which binary values could be dropped for the
    * serialization.
    * 
    * @param binValueOld, binValueNew values that will be provided during
    * deserialization and could be optimized out
    * 
    * Note: we should never optimize "null" values since it could be less
    * expensive to pass it along than to retrieve on the receiving side. As a
    * result, lite events don't have to be "compressed".
     */
    public static Object compressEventHolder(Object oEvent, com.tangosol.util.Binary binValueOld, com.tangosol.util.Binary binValueNew)
        {
        // import com.tangosol.util.Binary;
        // import java.util.Iterator;
        // import java.util.List;
        
        if (oEvent instanceof MapEventMessage)
            {
            MapEventMessage msgEvent = (MapEventMessage) oEvent;
        
            int nType = msgEvent.getEventType();
            if (binValueOld != null)
                {
                if (binValueOld.equals(msgEvent.getOldValue()))
                    {
                    nType |= EVT_OPT_OLD_SKIP;
                    }
                else if (binValueOld.equals(msgEvent.getNewValue()))
                    {
                    nType |= EVT_OPT_NEW_SWAP;
                    }
                }
        
            if (binValueNew != null)
                {
                if (binValueNew.equals(msgEvent.getNewValue()))
                    {
                    nType |= EVT_OPT_NEW_SKIP;
                    }
                else if (binValueNew.equals(msgEvent.getOldValue()))
                    {
                    nType |= EVT_OPT_OLD_SWAP;
                    }
                }
        
            msgEvent.setEventType(nType);
            }
        else if (oEvent != null)
            {
            for (Iterator iter = ((List) oEvent).iterator(); iter.hasNext();)
                {
                compressEventHolder(iter.next(), binValueOld, binValueNew);
                }
            }
        return oEvent;
        }
    
    /**
     * Process the events represented by the "compressed" event holder and
    * replace "tagged" binary values with corresponding specified values.
     */
    public static Object decompressEventHolder(Object oEvent, long lCacheId, com.tangosol.util.Binary binKey, com.tangosol.util.Binary binValueOld, com.tangosol.util.Binary binValueNew)
        {
        // import com.tangosol.util.Binary;
        // import java.util.Iterator;
        // import java.util.List;
        
        if (oEvent instanceof MapEventMessage)
            {
            MapEventMessage msgEvent = (MapEventMessage) oEvent;
        
            msgEvent.setCacheId(lCacheId);
            msgEvent.setKey(binKey);
        
            int nType = msgEvent.getEventType();
            switch (nType & (EVT_OPT_OLD_SKIP | EVT_OPT_OLD_SWAP))
                {
                case EVT_OPT_OLD_SKIP:
                    msgEvent.setOldValue(binValueOld);
                    nType &= ~EVT_OPT_OLD_SKIP;
                    break;
                case EVT_OPT_OLD_SWAP:
                    msgEvent.setOldValue(binValueNew);
                    nType &= ~EVT_OPT_OLD_SWAP;
                    break;
                }
        
            switch (nType & (EVT_OPT_NEW_SKIP | EVT_OPT_NEW_SWAP))
                {
                case EVT_OPT_NEW_SKIP:
                    msgEvent.setNewValue(binValueNew);
                    nType &= ~EVT_OPT_NEW_SKIP;
                    break;
                case EVT_OPT_NEW_SWAP:
                    msgEvent.setNewValue(binValueOld);
                    nType &= ~EVT_OPT_NEW_SWAP;
                    break;
                }
            msgEvent.setEventType(nType);
            }
        else if (oEvent != null)
            {
            for (Iterator iter = ((List) oEvent).iterator(); iter.hasNext();)
                {
                decompressEventHolder(iter.next(), lCacheId, binKey, binValueOld, binValueNew);
                }
            }
        
        return oEvent;
        }
    
    // Accessor for the property "CacheId"
    /**
     * Getter for property CacheId.<p>
    * The corresponding cache id.
     */
    public long getCacheId()
        {
        return __m_CacheId;
        }
    
    // Accessor for the property "CacheName"
    /**
     * Getter for property CacheName.<p>
    * (Calculated) The corresponding cache name.
     */
    public String getCacheName()
        {
        // overriden at the Service level
        return '[' + String.valueOf(getCacheId()) + ']';
        }
    
    // Accessor for the property "DeltaCompressor"
    /**
     * Getter for property DeltaCompressor.<p>
    * The DeltaCompressor to use for compressing the NewValue for standard
    * events.
     */
    public com.tangosol.io.DeltaCompressor getDeltaCompressor()
        {
        // import com.tangosol.util.NullImplementation;
        
        return NullImplementation.getDeltaCompressor();
        }
    
    // Declared at the super level
    /**
     * Getter for property Description.<p>
    * Used for debugging purposes (from toString). Create a human-readable
    * description of the specific Message data.
     */
    public String getDescription()
        {
        // import com.tangosol.util.MapEvent;
        
        return "CacheName="   + getCacheName() +
               ", EventType=" + MapEvent.getDescription(getEventType() & EVT_TYPE_MASK) +
               ", Key="       + getKey() +
               ", OldValue="  + getOldValue() +
               ", NewValue="  + getNewValue();
        }
    
    // Accessor for the property "EventSUID"
    /**
     * Getter for property EventSUID.<p>
    * A unique event SUID generated by the event originator.
     */
    public long getEventSUID()
        {
        return __m_EventSUID;
        }
    
    // Accessor for the property "EventType"
    /**
     * Getter for property EventType.<p>
    * The event type (one of the MapEvent.ENTRY_* constants) further decorated
    * with the EVT_* flags.
     */
    public int getEventType()
        {
        return __m_EventType;
        }
    
    // Accessor for the property "FilterId"
    /**
     * Getter for property FilterId.<p>
    * An array of Filter Ids that were responsible for raising this event.
     */
    public long[] getFilterId()
        {
        return __m_FilterId;
        }
    
    // Accessor for the property "Key"
    /**
     * Getter for property Key.<p>
    * The key.
     */
    public com.tangosol.util.Binary getKey()
        {
        return __m_Key;
        }
    
    // Accessor for the property "NewValue"
    /**
     * Getter for property NewValue.<p>
    * The new value (could be null for lite events).
     */
    public com.tangosol.util.Binary getNewValue()
        {
        return __m_NewValue;
        }
    
    // Accessor for the property "OldestPendingEventSUID"
    /**
     * Getter for property OldestPendingEventSUID.<p>
    * A SUID for the oldest pending event SUID issued by the event producer; -1
    * if there are none.
     */
    public long getOldestPendingEventSUID()
        {
        return __m_OldestPendingEventSUID;
        }
    
    // Accessor for the property "OldValue"
    /**
     * Getter for property OldValue.<p>
    * The old value (could be null for lite events).
     */
    public com.tangosol.util.Binary getOldValue()
        {
        return __m_OldValue;
        }
    
    // Accessor for the property "Partition"
    /**
     * Getter for property Partition.<p>
     */
    public int getPartition()
        {
        return __m_Partition;
        }
    
    // Accessor for the property "Version"
    /**
     * Getter for property Version.<p>
     */
    public long getVersion()
        {
        return __m_Version;
        }
    
    /**
     * Check if any of the events represented by the specified event holder
    * require the actual NewValue to be correctly decompressed.
     */
    public static boolean isCompressedNewValue(Object oEventHolder)
        {
        // import java.util.Iterator;
        // import java.util.List;
        
        if (oEventHolder == null)
            {
            return false;
            }
        
        if (oEventHolder instanceof MapEventMessage)
            {
            MapEventMessage msgEvent = (MapEventMessage) oEventHolder;
            int             nType    = msgEvent.getEventType();
        
            return (nType & (EVT_OPT_NEW_SKIP | EVT_OPT_NEW_SWAP)) != 0;
            }
        
        for (Iterator iter = ((List) oEventHolder).iterator(); iter.hasNext();)
            {
            if (isCompressedNewValue(iter.next()))
                {
                return true;
                }
            }
        return false;
        }
    
    /**
     * Check if any of the events represented by the specified event holder
    * require the actual OldValue to be correctly decompressed.
     */
    public static boolean isCompressedOldValue(Object oEventHolder)
        {
        // import java.util.Iterator;
        // import java.util.List;
        
        if (oEventHolder == null)
            {
            return false;
            }
        
        if (oEventHolder instanceof MapEventMessage)
            {
            MapEventMessage msgEvent = (MapEventMessage) oEventHolder;
            int             nType    = msgEvent.getEventType();
        
            return (nType & (EVT_OPT_OLD_SKIP | EVT_OPT_OLD_SWAP)) != 0;
            }
        
        for (Iterator iter = ((List) oEventHolder).iterator(); iter.hasNext();)
            {
            if (isCompressedOldValue(iter.next()))
                {
                return true;
                }
            }
        return false;
        }
    
    public boolean isExpired()
        {
        return (getEventType() & EVT_EXPIRED) != 0;
        }
    
    // Accessor for the property "Priming"
    /**
     * Getter for property Priming.<p>
    * Determines whether or not the event is a priming CacheEvent.
     */
    public boolean isPriming()
        {
        return (getEventType() & EVT_PRIMING) != 0;
        }
    
    // Accessor for the property "Synthetic"
    /**
     * Getter for property Synthetic.<p>
    * Calculates whether or not the event is a synthetic CacheEvent.
     */
    public boolean isSynthetic()
        {
        return (getEventType() & EVT_SYNTHETIC) != 0;
        }
    
    // Accessor for the property "Transformed"
    /**
     * Getter for property Transformed.<p>
     */
    public boolean isTransformed()
        {
        return (getEventType() & EVT_TRANSFORMED) != 0;
        }
    
    // Declared at the super level
    public void read(com.tangosol.io.ReadBuffer.BufferInput input)
            throws java.io.IOException
        {
        super.read(input);
        
        readImpl(input, false);
        }
    
    /**
     * @param fSupplemental  true if this MapEvent should be deserialized as a
    * part of other message deserialization
     */
    protected void readImpl(com.tangosol.io.ReadBuffer.BufferInput stream, boolean fSupplemental)
            throws java.io.IOException
        {
        // import com.tangosol.util.Binary;
        // import com.tangosol.util.ExternalizableHelper as com.tangosol.util.ExternalizableHelper;
        
        int nType;
        
        setEventSUID(com.tangosol.util.ExternalizableHelper.readLong(stream));
        setOldestPendingEventSUID(com.tangosol.util.ExternalizableHelper.readLong(stream));
        nType = com.tangosol.util.ExternalizableHelper.readInt(stream);
        
        if (fSupplemental)
            {
            ensureToMemberSet().readExternal(stream);
        
            int nEvent = nType & EVT_TYPE_MASK;
        
            // INSERT does not need an old value
            if (nEvent != ENTRY_INSERTED &&
                (nType & (EVT_OPT_OLD_SKIP | EVT_OPT_OLD_SWAP)) == 0)
                {
                // non-optimized old value
                setOldValue((Binary) com.tangosol.util.ExternalizableHelper.readObject(stream, null));
                }
        
            // DELETE does not need a new value
            if (nEvent != ENTRY_DELETED &&
                (nType & (EVT_OPT_NEW_SKIP | EVT_OPT_NEW_SWAP)) == 0)
                {
                // non-optimized new value
                setNewValue((Binary) com.tangosol.util.ExternalizableHelper.readObject(stream, null));
                }
            }
        else
            {
            setCacheId(com.tangosol.util.ExternalizableHelper.readLong(stream));
            setKey((Binary) com.tangosol.util.ExternalizableHelper.readObject(stream, null));
        
            Binary binValueOld = (Binary) com.tangosol.util.ExternalizableHelper.readObject(stream, null);
            Binary binValueNew = (Binary) com.tangosol.util.ExternalizableHelper.readObject(stream, null);
        
            if ((nType & EVT_DELTA_COMPRESSED) != 0)
                {
                // the new value was serialized in delta-compressed format;
                // extract the delta and adjust the event-type
                binValueNew = getDeltaCompressor().applyDelta(binValueOld, binValueNew).toBinary();
                nType &= ~EVT_DELTA_COMPRESSED;
                }
        
            setOldValue(binValueOld);
            setNewValue(binValueNew);
            }
        
        setEventType(nType);
        
        int cFilters = stream.readUnsignedShort();
        if (cFilters > 0)
            {
            long[] alFilterId = new long[cFilters];
        
            for (int i = 0; i < cFilters; i++)
                {
                alFilterId[i] = com.tangosol.util.ExternalizableHelper.readLong(stream);
                }
            setFilterId(alFilterId);
            }
        
        // @since 21.06 / 14.1.2
        if (stream.available() > 0)
            {
            setVersion(com.tangosol.util.ExternalizableHelper.readLong(stream));
            }
        
        // @since 21.06.2 / 14.1.2
        if (stream.available() > 0)
            {
            setPartition(com.tangosol.util.ExternalizableHelper.readInt(stream));
            }
        }
    
    /**
     * Read zero or more of MapEventMessages from the stream written by the
    * "writeSupplemental" method.
     */
    public static Object readSupplemental(com.tangosol.io.ReadBuffer.BufferInput stream, com.tangosol.coherence.component.util.daemon.queueProcessor.service.Grid service)
            throws java.io.IOException
        {
        // import com.tangosol.util.ExternalizableHelper;
        // import java.util.LinkedList;
        // import java.util.List;
        
        int cEvents = ExternalizableHelper.readInt(stream);
        switch (cEvents)
            {
            case 0:
                return null;
        
            case 1:
                {
                int nMsgType = ExternalizableHelper.readInt(stream);
        
                MapEventMessage event = (MapEventMessage) service.instantiateMessage(nMsgType);
                event.readImpl(stream, true);
                return event;
                }
        
            default:
                {
                List listEvents = new LinkedList();
                for (int i = 0; i < cEvents; i++)
                    {
                    int nMsgType = ExternalizableHelper.readInt(stream);
        
                    MapEventMessage event = (MapEventMessage) service.instantiateMessage(nMsgType);
                    event.readImpl(stream, true);
                    listEvents.add(event);
                    }
                return listEvents;
                }
            }
        }
    
    // Accessor for the property "CacheId"
    /**
     * Setter for property CacheId.<p>
    * The corresponding cache id.
     */
    public void setCacheId(long lId)
        {
        __m_CacheId = lId;
        }
    
    // Accessor for the property "EventSUID"
    /**
     * Setter for property EventSUID.<p>
    * A unique event SUID generated by the event originator.
     */
    public void setEventSUID(long lSUID)
        {
        __m_EventSUID = lSUID;
        }
    
    // Accessor for the property "EventType"
    /**
     * Setter for property EventType.<p>
    * The event type (one of the MapEvent.ENTRY_* constants) further decorated
    * with the EVT_* flags.
     */
    public void setEventType(int nType)
        {
        __m_EventType = nType;
        }
    
    // Accessor for the property "FilterId"
    /**
     * Setter for property FilterId.<p>
    * An array of Filter Ids that were responsible for raising this event.
     */
    public void setFilterId(long[] alFilterId)
        {
        __m_FilterId = alFilterId;
        }
    
    // Accessor for the property "Key"
    /**
     * Setter for property Key.<p>
    * The key.
     */
    public void setKey(com.tangosol.util.Binary binKey)
        {
        __m_Key = binKey;
        }
    
    // Accessor for the property "NewValue"
    /**
     * Setter for property NewValue.<p>
    * The new value (could be null for lite events).
     */
    public void setNewValue(com.tangosol.util.Binary binValue)
        {
        __m_NewValue = binValue;
        }
    
    // Accessor for the property "OldestPendingEventSUID"
    /**
     * Setter for property OldestPendingEventSUID.<p>
    * A SUID for the oldest pending event SUID issued by the event producer; -1
    * if there are none.
     */
    public void setOldestPendingEventSUID(long lSUID)
        {
        __m_OldestPendingEventSUID = lSUID;
        }
    
    // Accessor for the property "OldValue"
    /**
     * Setter for property OldValue.<p>
    * The old value (could be null for lite events).
     */
    public void setOldValue(com.tangosol.util.Binary binValue)
        {
        __m_OldValue = binValue;
        }
    
    // Accessor for the property "Partition"
    /**
     * Setter for property Partition.<p>
     */
    public void setPartition(int nPartition)
        {
        __m_Partition = nPartition;
        }
    
    // Accessor for the property "Version"
    /**
     * Setter for property Version.<p>
     */
    public void setVersion(long nPartition)
        {
        __m_Version = nPartition;
        }
    
    // Declared at the super level
    public void write(com.tangosol.io.WriteBuffer.BufferOutput output)
            throws java.io.IOException
        {
        super.write(output);
        
        writeImpl(output, false);
        }
    
    /**
     * @param fSupplemental  true if this MapEvent should be serialized as a
    * part of other message serialization.
    * @param binValue  a value for which the serialization could be optimized
    * out
     */
    protected void writeImpl(com.tangosol.io.WriteBuffer.BufferOutput stream, boolean fSupplemental)
            throws java.io.IOException
        {
        // import com.tangosol.io.ReadBuffer;
        // import com.tangosol.util.Binary;
        // import com.tangosol.util.ExternalizableHelper as com.tangosol.util.ExternalizableHelper;
        
        int nType = getEventType();
        
        com.tangosol.util.ExternalizableHelper.writeLong(stream, getEventSUID());
        com.tangosol.util.ExternalizableHelper.writeLong(stream, getOldestPendingEventSUID());
        
        if (fSupplemental)
            {
            com.tangosol.util.ExternalizableHelper.writeInt(stream, nType);
            ensureToMemberSet().writeExternal(stream);
        
            int nEvent = nType & EVT_TYPE_MASK;
        
            // INSERT does not need an old value
            if (nEvent != ENTRY_INSERTED &&
                (nType & (EVT_OPT_OLD_SKIP | EVT_OPT_OLD_SWAP)) == 0)
                {
                // non-optimized old value
                com.tangosol.util.ExternalizableHelper.writeObject(stream, getOldValue());
                }
        
            // DELETE does not need a new value
            if (nEvent != ENTRY_DELETED &&
                (nType & (EVT_OPT_NEW_SKIP | EVT_OPT_NEW_SWAP)) == 0)
                {
                // non-optimized new value
                com.tangosol.util.ExternalizableHelper.writeObject(stream, getNewValue());
                }
            }
        else
            {
            Binary binValueOld = getOldValue();
            Binary binValueNew = getNewValue();
        
            if (binValueOld != null && binValueNew != null)
                {
                // use the delta-compressor for standard update events and
                // adjust the event type to reflect the compressed NewValue
                ReadBuffer bufDelta = getDeltaCompressor().extractDelta(binValueOld, binValueNew);
                binValueNew = bufDelta == null ? null : bufDelta.toBinary();
                nType |= EVT_DELTA_COMPRESSED;
                }
        
            com.tangosol.util.ExternalizableHelper.writeInt(stream, nType);
            com.tangosol.util.ExternalizableHelper.writeLong(stream, getCacheId());
            com.tangosol.util.ExternalizableHelper.writeObject(stream, getKey());
            com.tangosol.util.ExternalizableHelper.writeObject(stream, binValueOld);
            com.tangosol.util.ExternalizableHelper.writeObject(stream, binValueNew);
            }
        
        // for supplemental write, the values could be just "tags"
        
        long[] alFilterId = getFilterId();
        int    cFilters   = alFilterId == null ? 0 : alFilterId.length;
        
        stream.writeShort(cFilters);
        for (int i = 0; i < cFilters; i++)
            {
            com.tangosol.util.ExternalizableHelper.writeLong(stream, alFilterId[i]);
            }
        
        // since the MapEvent could be a multi-point message,
        // we cannot clean up the values (COH-1109)
        
        // @since 14.1.2
        // write the version of the change
        com.tangosol.util.ExternalizableHelper.writeLong(stream, getVersion());
        com.tangosol.util.ExternalizableHelper.writeInt(stream, getPartition());
        }
    
    /**
     * Write zero or more MapEventMessages represented by the EventHolder to the
    * stream. Theses event messages are supplemental to a main message that
    * carries CacheId, Key as well as the specified ValueOld and ValueNew,
    * which should be optimized out. All these values will be passed to
    * "readSupplemental" during deserialization.
    * 
    * The holder content can be:
    * 
    * - null (no events)
    * - MapEventMessage instance (one and only one event)
    * - List of MapEventMessage's (for more than one event)
     */
    public static void writeSupplemental(com.tangosol.io.WriteBuffer.BufferOutput stream, Object oEventHolder)
            throws java.io.IOException
        {
        // import com.tangosol.util.ExternalizableHelper;
        // import java.util.Iterator;
        // import java.util.List;
        
        if (oEventHolder == null)
            {
            ExternalizableHelper.writeInt(stream, 0);
            }
        else if (oEventHolder instanceof MapEventMessage)
            {
            MapEventMessage msgEvent = (MapEventMessage) oEventHolder;
        
            ExternalizableHelper.writeInt(stream, 1);
        
            ExternalizableHelper.writeInt(stream, msgEvent.getMessageType());
            msgEvent.writeImpl(stream, true);
            }
        else
            {
            List listEvents = (List) oEventHolder;
        
            ExternalizableHelper.writeInt(stream, listEvents.size());
        
            for (Iterator iter = listEvents.iterator(); iter.hasNext();)
                {
                MapEventMessage msgEvent = (MapEventMessage) iter.next();
        
                ExternalizableHelper.writeInt(stream, msgEvent.getMessageType());
                msgEvent.writeImpl(stream, true);
                }
            }
        }
    }
